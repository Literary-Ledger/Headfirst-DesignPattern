
## 상태패턴

>[!INFO] State Pattern
> 상태패턴을 사용하면 객체 내부의 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있음
> 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다.
 
상태를 별도의 클래스로 캡슐화 한다음 다음 현재 상태를 나타내는 객체에게 행동을 위임하므로
내부 상태가 바뀔 때 행동이 달라지게 된다는 사실을 쉽게 알 수 있다.

`클래스가 바뀌는 것 같은`결과를 얻는다는 것은 ?
클라이언트의 관점에서 생각해봤을 때 만약 지금 사용하는 객체의 행동이 완전히 달라진다면
마치 그 객체가 다른 클래스로부터 만들어진 객체처럼 느껴질 것

물론 실제로 다른 클래스로 변신하는 것이 아닌 여러 상태 객체를 바꿔가며 사용하니
이런 결과를 얻을 수 있는거지만

## 상태패턴 vs 전략패턴
상태 패턴을 사용할 땐, 상태 객체에 일련의 행동이 캡슐화됨
상황에 따라 Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡기게 된다.
그 객체 내부 상태에 따라 현재 상태를 나타내는 객체가 바뀌게 되고, 그 결과로 Context 객체의 행동도
자연스럽게 바뀌게 된다. 클라이언트는 상태 객체를 몰라도 됨

허나 전략패턴을 사용할 땐 일반적으로 클라이언트가 Context 객체에게 어떤 전략
객체를 사용할 지를 지정해줌, 전략 패턴은 주로 실행 시에 전략 객체를
변경할 수 있는 유연성을 제공하는 용도로 쓰인다. 보통 가장 적합한 전략 객체를 선택해서
사용하게 됨

---

## 프록시 패턴

### 원격 프록시

GumballMonitor 클래스에 GumballMachine 레퍼런스만 넘겨주면 보고서를 만들어줌.
현재 상태에서의 문제는 이 코드가 같은 JVM 안에서만 돌아가는데, CEO는 멀리 떨어져있는 컴퓨터에서
모니터링 하고싶어함, 그러면 GumballMonitor 클래스는 그대로 두고
원격 객체의 `Proxy` 만 넘기면 됨

#### Proxy
진짜 객체를 대신하는 역할을 맡음
여기서는 뽑기 기계 객체 역할
근데 실제로는 네트워크로 멀리 떨여져있는 진짜 GumballMachine 클래스와 데이터를 주고받는 것

코드는 그대로 두고 GumballMonitor의 `Proxy`를 레퍼런스로 건내주고, 그 프록시는
진짜 객체처럼 행동하지만 실제로는 네트워크로 진짜 객체와 데이터를 주고받는 것